{"version":3,"sources":["components/card/card.component.jsx","components/card-list/card-list.components.jsx","components/search-box/search-box.component.jsx","App.js","index.js"],"names":["Card","props","className","alt","src","monster","id","name","email","CardList","monsters","map","key","SearchBox","placeholder","handleChange","type","onChange","App","e","setState","searchField","target","value","state","fetch","then","response","json","users","this","filteredMonsters","filter","toLowerCase","includes","Component","ReactDOM","render","document","getElementById"],"mappings":"qVAKaA,G,MAAO,SAACC,GAAD,OAClB,yBAAKC,UAAU,kBACb,yBAAKC,IAAI,UAAUC,IAAG,+BAA0BH,EAAMI,QAAQC,GAAxC,4BACtB,4BAAKL,EAAMI,QAAQE,MACnB,2BAAIN,EAAMI,QAAQG,UCHTC,G,MAAW,SAAAR,GAAK,OAS3B,yBAAKC,UAAU,aACZD,EAAMS,SAASC,KAAI,SAACN,GAAD,OAClB,kBAAC,EAAD,CAAMO,IAAKP,EAAQC,GAAID,QAASA,UCVzBQ,G,MAAY,SAAC,GAAD,IAAGC,EAAH,EAAGA,YAAaC,EAAhB,EAAgBA,aAAhB,OAEvB,2BACEb,UAAU,SACVc,KAAK,SACLF,YAAaA,EACbG,SAAUF,OCgDCG,G,kBAvDb,aAAe,IAAD,8BACZ,+CA8BFH,aAAe,SAACI,GACd,EAAKC,SAAS,CAAEC,YAAaF,EAAEG,OAAOC,SA7BtC,EAAKC,MAAQ,CACXd,SAAU,GACVW,YAAa,IALH,E,iFAeO,IAAD,OAClBI,MAAM,8CACHC,MAAK,SAAAC,GAAQ,OACZA,EAASC,UAEVF,MAAK,SAAAG,GAAK,OAAI,EAAKT,SAAS,CAAEV,SAAUmB,S,+BAenC,IAAD,EAC2BC,KAAKN,MAA/Bd,EADD,EACCA,SAAUW,EADX,EACWA,YACZU,EAAmBrB,EAASsB,QAAO,SAAA3B,GAAO,OAE9CA,EAAQE,KAAK0B,cAAcC,SAASb,EAAYY,kBAGlD,OACE,yBAAK/B,UAAU,OACb,gDACA,kBAAC,EAAD,CACEY,YAAY,kBACZC,aAAce,KAAKf,eAErB,kBAAC,EAAD,CAAUL,SAAUqB,S,GAlDVI,cCClBC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,W","file":"static/js/main.094e7ade.chunk.js","sourcesContent":["import React from 'react';\r\nimport './card.styles.css';\r\n\r\n\r\n// We no lonher have access to monster so we pass it to the params\r\nexport const Card = (props) => (\r\n  <div className='card-container'>\r\n    <img alt='monster' src={`https://robohash.org/${props.monster.id}?set=set2&size=180x180`} />\r\n    <h2>{props.monster.name}</h2>\r\n    <p>{props.monster.email}</p>\r\n  </div>\r\n)","import React from 'react';\r\nimport { Card } from '../card/card.component';\r\nimport './card-list.styles.css';\r\n\r\n\r\n// components takes in props and its the param that we get from our functional component\r\nexport const CardList = props => (\r\n  // console.log(props);\r\n\r\n  // if we replace Hello and render {props.children} it uses the code or html or whatever you passed in the App in this case i put Lia in h1.\r\n  // After we remove {props.children} and replace it with the code that was in the App.js.\r\n  // we use .map cause it returns us the return of w/e func we pass to it iterated over every el in the arr.\r\n  // if we dont add a key we'll get an error messge that we need 1.\r\n  // Reason we want a unique key is cause React needs to know what el it needs to update.\r\n  // its not off state its off of the props so we change state to props\r\n  <div className='card-list'>\r\n    {props.monsters.map((monster) => (\r\n      <Card key={monster.id} monster={monster} />\r\n    ))}\r\n  </div>\r\n);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import React from 'react';\r\nimport './search-box.styles.css';\r\n\r\n\r\n// Functional components... they dont have access to state cause they dont have access to constructor(), they also dont have access to life cycle methods, they dont have internal state, cause they dont need to use lifecycle methods for internal state.\r\n// Sometimes all we wanna do is render some HTML and thats what functional components really is.\r\n// Unlike a class component a functional component is just a component that gets some props and returns some html thats we use () and not {} at the end.\r\nexport const SearchBox = ({ placeholder, handleChange }) => (\r\n  // apply class name after copying from App.js\r\n  <input\r\n    className='search'\r\n    type='search'\r\n    placeholder={placeholder}\r\n    onChange={handleChange}\r\n  />\r\n)\r\n\r\n\r\n\r\n\r\n\r\n","import React, { Component } from 'react';\nimport { CardList } from './components/card-list/card-list.components';\nimport { SearchBox } from './components/search-box/search-box.component';\nimport './App.css';\n\nclass App extends Component {\n  constructor() {\n    super();\n\n    this.state = {\n      monsters: [],\n      searchField: ''\n    };\n\n    // define \"this\" in the constructor or else we get an error useing this.setState with handleChange() cause of scope, we put here cause constructor() get run first.\n    // We bind it like this.handleChange.bind(this), so what is .bin() its a method on any func that returns a new func where the context of \"this\" is set to whatever we passed to it and the context of \"this\" that we're setting in handleChange() is the \"this\" keyword that is defined inside our constructor/here..but if we use arrow funcs we dont need to do this anymore\n    // this.handleChange = this.handleChange.bind(this)\n\n  }\n\n\n  componentDidMount() {\n    fetch('https://jsonplaceholder.typicode.com/users')\n      .then(response =>\n        response.json()\n      )\n      .then(users => this.setState({ monsters: users }))\n  }\n\n  // For the search incase we need to use it more than once\n  // handleChange(e) {\n  //   this.setState({ searchField: e.target.value });\n  // }\n\n  // handleChange but with es6 arrow function which is better cause it lets them set the context of \"this\" in whatever it was that decalred it in the first place.\n  // Arrow funcs auto allow you to set \"this\" when the ()=>{} is defined.\n  // So when our component is getting run by JS for the first time and it has to instantiate the new App class it checks inside and it sees that theres \"this\" handle change methd that points to a arrow func in\n  handleChange = (e) => {\n    this.setState({ searchField: e.target.value });\n  }\n\n  render() {\n    const { monsters, searchField } = this.state;\n    const filteredMonsters = monsters.filter(monster =>\n\n      monster.name.toLowerCase().includes(searchField.toLowerCase())\n    )\n\n    return (\n      <div className='App'>\n        <h1>Monsters Rolodex</h1>\n        <SearchBox\n          placeholder='search monsters'\n          handleChange={this.handleChange}\n        />\n        <CardList monsters={filteredMonsters} />\n      </div>\n\n    );\n  }\n}\nexport default App;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//                       FIRST HALF  video 28\n/*\nimport React, { Component } from 'react';\nimport { CardList } from './components/card-list/card-list.components';\nimport { SearchBox } from './components/search-box/search-box.component';\nimport './App.css';\n\n// Component is part of the React library and destructure it, but if we didnt we can just use in the class as React.Component instead of jut Component cause its a property of React.\n// When we're doing class App extends Components what its doing/saying is \"hey i want whatever functionality that react component and im going to add on to it\".\n// The render() method comes built in with Component, and this Component gives us some batteries options to use in our component so that we dont have constantly repeat ourself. We use something that React says hey this is a component and we just tack on some specific functionality.\n// We'll learn about lifecycle methods and how these components have some important methods already on them like componentDidCatch etc...\n// What lifecycle methods are methods that get called at different stages of when this component get rendered.\n// What componentDidMount does is when this component mounts(essentially when React puts our component on the page/renders to DOM for first time) and it calls every block of code we write inside of it componentDidMount(){}\n// Each component in the end of the day is a function that renders, so if state changes its going to notify this component/parent and say hey run the render function again each time it gets updated.\nclass App extends Component {\n  constructor() {\n    super();\n\n    // default value\n    this.state = {\n      // Set property on our STATE obj to 'Hello Towiah'\n      // string: 'Hello Towiah'\n\n      // we want this intial arr to be empty\n      monsters: [\n        // {\n        //   name: 'Frankenstein',\n        //   id: 'asc1'\n        // },\n        // {\n        //   name: 'Dracula',\n        //   id: 'asr2'\n        // },\n        // {\n        //   name: 'Zombie',\n        //   id: 'as3'\n        // }\n      ],\n      // stored value to search/filter monsters\n      searchField: ''\n    }\n  }\n\n  // What componentDidMount does is when this component mounts(essentially when React puts our component on the page/renders to DOM for first time) and it calls every block of code we write inside of it componentDidMount(){}\n  componentDidMount() {\n    // use fetch to fetch from URL, API request , and what fetch returns us is a Promise.\n    fetch('https://jsonplaceholder.typicode.com/users')\n      // but the promise gives us a response of the actual body of our response\n      .then(response =>\n        // lets return json format\n        response.json()\n      )\n      // then return to us as new promise which we will have as the body... then what we want to do is call setState({monsters:users}) as arr of users\n      .then(users => this.setState({ monsters: users }))\n  }\n\n  // setState lets us modify the object above on every HTML el.\n  // button onCLick takes a func that get called when clicked\n  // youre not allowed to modify state w/o setState, react is going to itercept that click and its going to report back and say i got click on the DOM what do I do? in this case we're going to say when clicked update the state but not modify it automatically. onClick happened state get updated using seState and the changes is going to re-render the components so we can go through that flow again\n  render() {\n    // filter the monsters that dont have the text we put and we do it in the render(), but we dont want to modify the state of monster array cause we want to keep the raw data just in case somewhere in the component we need to use the base unmodified arr, what we do is make a new arr with .filter() method, so we first destructure {}, which allows us to pull properties off of an object and set them to constants that we pur inside the {} and = the actual object we want to destructure from which is this.state, so we basically pull properties off of this.state and put them in {}.\n    const { monsters, searchField } = this.state;\n    // these below are the same as the destructure above.\n    // const monsters = this.state.monsters;\n    // const searchField = this.state.searchField\n\n    // With filter we get back a new arr based off of the func we pass into it.\n    const filteredMonsters = monsters.filter(monster =>\n      // take the name and lowecase cause we dont want search to be case sensitive and add .includes() and what it does is it just checks whether we pass a string or not is actually in the monster\n      monster.name.toLowerCase().includes(searchField.toLowerCase())\n    )\n\n    return (\n      // <div className='App'>\n      //   <header className='App-header'>\n      //     <img src={logo} className='App-logo' alt='logo' />\n      //     <p>{this.state.string}</p>\n      //     <button onClick={() => this.setState({ string: 'TOWIAHHH' })}>Change text</button>\n      //   </header>\n      // </div>\n\n      //the props will be any param that we pass into cardList, so if theres a prop called name and we pass in 'towiah'.\n      // Children is what you put inbetween <Card><Card/> components.\n      // If you put a name inbetween then the children prop will be the new name inbetween the component name tags.\n      // For the search section when you type the first letter in its empty cause of async so React gave us something and its a callback and goes as a second param after the searchFild: e.target.value and the CB runs after setState is finished.\n      <div className='App'>\n        <SearchBox\n          placeholder='search monsters'\n          handleChange={e =>\n            this.setState({ searchField: e.target.value })}\n        />\n        <CardList monsters={filteredMonsters} />\n      </div>\n\n    );\n  }\n}\nexport default App;\n*/\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n// looks at document with the id of root and is replacing it with the function <App />\nReactDOM.render(<App />, document.getElementById('root'));\n\n\n"],"sourceRoot":""}